Question: In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.

 

Example 1:


Input: edges = [[1,2],[1,3],[2,3]]
Output: [2,3]
Example 2:


Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
Output: [1,4]
 

Constraints:

n == edges.length
3 <= n <= 1000
edges[i].length == 2
1 <= ai < bi <= edges.length
ai != bi
There are no repeated edges.
The given graph is connected.




Solution:  To solve this problem, I used the Union-Find  data structure to efficiently detect cycles in an undirected graph. The idea is to process each edge and determine whether it forms a cycle. I initialized the Union-Find class with a parent array and a rank array to optimize merging operations. The find() function implements path compression, ensuring that each node directly points to its root, reducing lookup time to nearly O(1). The union() function merges two sets, always attaching the smaller tree to the larger one, which helps keep the structure balanced.

For each edge [u, v], I checked if u and v already share the same root . If they do, adding this edge would create a cycle, making it the redundant connection that needs to be removed. Otherwise, I merged the sets using union(). The first edge that fails the union operation is the redundant edge, and I returned it immediately. 